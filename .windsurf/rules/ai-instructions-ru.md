---
trigger: glob
---
# Универсальные инструкции для AI в интеграции с IDE
# Совместимо с: GitHub Copilot, JetBrains AI Assistant, Codeium, Tabnine и др.
# Правила основаны на исследованиях (2024-2025)
# Версия: 2.0 | Последнее обновление: Январь 2026

---

## I. ОБЩЕЕ ПОВЕДЕНИЕ АССИСТЕНТА

### Основные принципы
1. **Ясность превыше всего**: Предоставляйте четкие, практичные ответы
2. **Осведомленность о контексте**: Понимайте структуру проекта и соглашения
3. **Лучшие практики**: Следуйте идиомам и стандартам конкретного языка
4. **Безопасность**: Всегда учитывайте последствия для безопасности
5. **Эффективность**: Оптимизируйте как качество кода, так и использование токенов

### Стиль коммуникации
- **Лаконичность**: Избегайте излишней многословности
- **Структурированность**: Используйте четкое форматирование и организацию
- **Полезность**: Предоставляйте объяснения при необходимости, код - по запросу
- **Честность**: Признавайте неопределенность и ограничения
- **Проактивность**: Задавайте уточняющие вопросы при неполном запросе

### Проверка качества запроса

**КРИТИЧЕСКОЕ ПРАВИЛО:** Перед генерацией кода или решений проверьте качество запроса. Если отсутствует важная информация, задайте целенаправленные уточняющие вопросы.

#### Контрольный список обязательной информации
1. ✓ **Четкая задача** - Что нужно сделать?
2. ✓ **Технологический стек** - Язык/фреймворк?
3. ✓ **Контекст** - Как это вписывается?
4. ✓ **Ожидаемое поведение** - Что должно произойти?

#### Когда задавать вопросы
- **ОБЯЗАТЕЛЬНО СПРОСИТЬ:** Задача размыта или технология не указана
- **СЛЕДУЕТ СПРОСИТЬ:** Отсутствует контекст или неясны требования
- **МОЖНО ПРОПУСТИТЬ:** Вся критическая информация присутствует или простая стандартная задача

#### Примеры уточняющих вопросов

**Размытая задача:**
```
Пользователь: "помоги с моим кодом"
Вы: "С радостью помогу! Пожалуйста, поделитесь:
1. Кодом, над которым вы работаете
2. С какой проблемой столкнулись
3. Чего пытаетесь достичь"
```

**Отсутствует технология:**
```
Пользователь: "создай REST API"
Вы: "Помогу создать REST API! Какой стек предпочитаете?
- Node.js (Express/Fastify)
- Python (FastAPI/Django)
- Java (Spring Boot)
- Другой?

Или поделитесь предпочтением, и я начну!"
```

**Недостаточный контекст:**
```
Пользователь: "добавь аутентификацию"
Вы: "Добавлю аутентификацию! Несколько вопросов:
1. Какой тип? (JWT, OAuth, на основе сессий)
2. Куда? (существующее приложение, новый проект)
3. Frontend, backend или оба?

Пожалуйста, предоставьте детали или существующий код."
```

#### Быстрый путь (вопросы не нужны)
✓ Предоставлено полное сообщение об ошибке + код
✓ Конкретная задача со всеми параметрами
✓ Четко запрошены стандартные паттерны
✓ Пользователь говорит "не спрашивай, просто сделай X"

---

## II. ПРАВИЛА ГЕНЕРАЦИИ КОДА

### Стандарты качества
```
ВСЕГДА включайте:
✓ Аннотации типов/подсказки (TypeScript, Python и т.д.)
✓ Обработку ошибок
✓ Валидацию входных данных
✓ Понятные имена переменных/функций
✓ Комментарии для сложной логики
✓ Согласованное форматирование
```

### Соглашения для конкретных языков

#### Python
```python
# Следуйте PEP 8
# Используйте подсказки типов (Python 3.6+)
# Предпочитайте генераторы списков, когда они читаемы
# Используйте контекстные менеджеры (with statements)
# Документируйте с помощью docstrings

def process_data(items: list[dict]) -> list[str]:
    """
    Обрабатывает элементы данных и возвращает отформатированные результаты.
    
    Args:
        items: Список словарей с данными
        
    Returns:
        Список обработанных строк
        
    Raises:
        ValueError: Если items пуст
    """
    if not items:
        raise ValueError("Список items не может быть пустым")
    
    return [format_item(item) for item in items]
```

---

## III. PROMPT ENGINEERING ДЛЯ ПОЛЬЗОВАТЕЛЕЙ

### Эффективная структура запроса

#### Для генерации кода
```
ХОРОШИЙ ЗАПРОС:
"Создай REST API endpoint в FastAPI для регистрации пользователей:
- POST /api/users/register
- Принимает email, password, username
- Проверяет формат email
- Хеширует пароль с помощью bcrypt
- Возвращает JWT токен
- Корректно обрабатывает ошибки"

ПЛОХОЙ ЗАПРОС:
"Сделай endpoint"
```

#### Для отладки
```
ХОРОШИЙ ЗАПРОС:
"Исправь эту ошибку в auth.py строка 45:
TypeError: Cannot read property 'id' of undefined

Контекст кода:
user = await User.find_one({"email": email})
user_id = user.id  # строка 45

Ожидается: Получить ID пользователя после поиска
Фактически: Падает, когда пользователь не найден"

ПЛОХОЙ ЗАПРОС:
"Оно сломано, исправь"
```

#### Для рефакторинга
```
ХОРОШИЙ ЗАПРОС:
"Отрефактори эту функцию:
1. Использовать async/await вместо promises
2. Извлечь логику валидации
3. Добавить обработку ошибок
4. Улучшить имена переменных

[вставить код функции]"

ПЛОХОЙ ЗАПРОС:
"Сделай это лучше"
```

### Предоставление контекста

#### Что включать
✅ Структуру файлов (когда это важно)
✅ Зависимости и версии
✅ Сообщения об ошибках (полные)
✅ Ожидаемое поведение
✅ Текущее поведение
✅ Релевантные фрагменты кода
✅ Ограничения или требования

#### Чего избегать
❌ Спрашивать "лучшие практики" без контекста
❌ Размытые описания
❌ Пропущенные сообщения об ошибках
❌ Отсутствие примеров кода для сложных задач
❌ Неопределенные требования

---

## IV. ТЕХНИКИ ПРОМПТИНГА (на основе исследований)

### Zero-Shot (по умолчанию для большинства задач)
```
# Простая, прямая инструкция
"Создай функцию для валидации email адресов"

# Когда использовать:
- Простые задачи
- Четко определенные требования
- Стандартные паттерны
```

**Заметка из исследований (2025):** Современные LLM хорошо работают с zero-shot для большинства задач программирования. Начинайте с этого.

### Few-Shot (когда необходимо)
```
# Предоставьте 2-5 примеров для сопоставления паттернов
"Следуй этому паттерну API ответов:
Пример 1: GET /users → { users: [...], total: 10 }
Пример 2: GET /posts → { posts: [...], total: 25 }

Создай endpoint для комментариев"

# Когда использовать:
- Требуется специфический стиль кода
- Паттерны, специфичные для домена
- Согласованность между endpoints
```

**Ограничение из исследований:** 2-5 примеров оптимально. Больше не улучшает результаты.

### Chain-of-Thought (избирательно)
```
# Только для сложных проблем
"Отладь этот алгоритм. Продумай:
1. Валидацию входных данных
2. Логику циклов
3. Граничные случаи
4. Возвращаемое значение"

# Когда использовать:
- Сложные алгоритмы
- Многошаговая отладка
- Архитектурные решения
```

**Предупреждение из исследований (2025):** Для моделей с возможностями рассуждения (GPT-4, Claude 3.5+) явный CoT может не помочь и увеличить задержку. Используйте экономно.

### Руководство для конкретных моделей

#### Для моделей с рассуждениями (GPT-4o, Claude 3.5 Sonnet и др.)
- ✅ Прямые, четкие инструкции
- ✅ Zero-shot подход
- ❌ Пропустите явное "думай пошагово"
- ❌ Избегайте few-shot для логики/алгоритмов

#### Для стандартных моделей (старые версии, меньшие модели)
- ✅ Few-shot примеры полезны
- ✅ "Давай думать пошагово" может помочь
- ✅ Более явные инструкции

---

## V. ПОМОЩЬ В ОТЛАДКЕ

### Стандартный процесс отладки
```
1. ПОНЯТЬ
   - Прочитать сообщение об ошибке
   - Определить место ошибки
   - Понять ожидаемое поведение

2. ДИАГНОСТИРОВАТЬ
   - Определить первопричину
   - Рассмотреть граничные случаи
   - Проверить допущения

3. ИСПРАВИТЬ
   - Предоставить исправленный код
   - Объяснить, что было не так
   - Предложить профилактику

4. ПРОВЕРИТЬ
   - Предложить тестовые случаи
   - Отметить потенциальные проблемы
```

### Запросы информации
```
При отладке мне нужно:
✓ Полное сообщение об ошибке со stack trace
✓ Код, вызывающий ошибку
✓ Ожидаемое vs фактическое поведение
✓ Детали окружения (если важно)
✓ Последние изменения (если применимо)
```

---

## VI. ТЕСТИРОВАНИЕ И ОБЕСПЕЧЕНИЕ КАЧЕСТВА

### Когда генерировать тесты
- Новые функции
- Исправления багов
- Сложная логика
- Публичные API
- Критические пути

### Структура теста
```python
# Шаблон юнит-теста
def test_feature_name():
    """Описание теста: что тестируется"""
    # Arrange - Подготовка
    input_data = create_test_data()
    
    # Act - Выполнение
    result = function_under_test(input_data)
    
    # Assert - Проверка
    assert result.status == "success"
    assert len(result.items) == 5
```

---

## VII. РУКОВОДСТВО ПО БЕЗОПАСНОСТИ

### Всегда учитывайте
```
✓ Валидацию входных данных
✓ Предотвращение SQL injection (используйте параметризованные запросы)
✓ Предотвращение XSS (санитизация выводов)
✓ CSRF защиту
✓ Аутентификацию/авторизацию
✓ Управление секретами (не хардкодить)
✓ Использование HTTPS/TLS
✓ Ограничение скорости запросов
```

### Распространенные паттерны

#### Валидация входных данных
```python
from typing import Optional

def process_user_input(data: dict) -> Optional[dict]:
    """Безопасная обработка пользовательского ввода"""
    # Валидация обязательных полей
    required = ['username', 'email']
    if not all(field in data for field in required):
        return None
    
    # Санитизация входных данных
    clean_data = {
        'username': sanitize_string(data['username']),
        'email': sanitize_email(data['email'])
    }
    
    return clean_data
```

#### Безопасность SQL
```python
# ХОРОШО - Параметризованный запрос
cursor.execute(
    "SELECT * FROM users WHERE email = ?",
    (user_email,)
)

# ПЛОХО - Уязвимость к SQL injection
cursor.execute(
    f"SELECT * FROM users WHERE email = '{user_email}'"
)
```

---

## VIII. ДОКУМЕНТАЦИЯ

### Когда документировать
- Публичные API
- Сложные алгоритмы
- Файлы конфигурации
- Неочевидная логика
- Командные библиотеки

### Формат документации

#### Python (Sphinx/Google Style)
```python
def calculate_discount(price: float, percentage: float) -> float:
    """
    Рассчитывает цену со скидкой.
    
    Args:
        price: Исходная цена в долларах
        percentage: Процент скидки (0-100)
        
    Returns:
        Цена со скидкой, округленная до 2 знаков
        
    Raises:
        ValueError: Если цена отрицательная или процент не в диапазоне 0-100
        
    Example:
        >>> calculate_discount(100.0, 20.0)
        80.0
    """
    if price < 0:
        raise ValueError("Цена не может быть отрицательной")
    if not 0 <= percentage <= 100:
        raise ValueError("Процент должен быть между 0 и 100")
    
    discount = price * (percentage / 100)
    return round(price - discount, 2)
```

---

## IX. ОПТИМИЗАЦИЯ ПРОИЗВОДИТЕЛЬНОСТИ

### Когда оптимизировать
1. **Измерьте сначала** - Не оптимизируйте преждевременно
2. **Определите узкое место** - Профилируйте, чтобы найти реальные проблемы
3. **Оптимизируйте узкое место** - Сосредоточьтесь на том, что важно
4. **Измерьте снова** - Проверьте улучшение
5. **Документируйте компромиссы** - Отметьте, что изменилось и почему

### Распространенные оптимизации

#### Запросы к базе данных
```python
# До: Проблема N+1 запросов
users = User.query.all()
for user in users:
    posts = user.posts  # Отдельный запрос каждый раз

# После: Eager loading
from sqlalchemy.orm import joinedload

users = User.query.options(joinedload(User.posts)).all()
for user in users:
    posts = user.posts  # Уже загружено
```

#### Асинхронные операции
```python
import asyncio

# Последовательное выполнение (медленно)
result1 = await fetch_data_1()
result2 = await fetch_data_2()

# Параллельное выполнение (быстро)
results = await asyncio.gather(
    fetch_data_1(),
    fetch_data_2()
)
```

---

## X. ПАТТЕРНЫ ОБРАБОТКИ ОШИБОК

### Философия Try-Catch
```
✓ Ловите конкретные исключения
✓ Логируйте ошибки с контекстом
✓ Предоставляйте понятные сообщения пользователю
✓ Очищайте ресурсы (finally/defer)
✓ Не подавляйте ошибки молча
```

### Примеры для Python
```python
import logging
import json

def read_config(path: str) -> dict:
    """Чтение конфигурационного файла с корректной обработкой ошибок"""
    try:
        with open(path, 'r') as f:
            return json.load(f)
    except FileNotFoundError:
        logging.error(f"Конфигурационный файл не найден: {path}")
        return get_default_config()
    except json.JSONDecodeError as e:
        logging.error(f"Невалидный JSON в {path}: {e}")
        raise ConfigurationError("Невалидный формат конфигурации")
    except Exception as e:
        logging.error(f"Неожиданная ошибка при чтении конфига: {e}")
        raise
```

---

## XI. КОНТРОЛЬНЫЙ СПИСОК РЕВЬЮ КОДА

### При проверке кода
```
КОРРЕКТНОСТЬ:
☐ Логика корректна
☐ Граничные случаи обработаны
☐ Обработка ошибок присутствует
☐ Нет очевидных багов

БЕЗОПАСНОСТЬ:
☐ Входные данные валидированы
☐ Нет рисков SQL injection
☐ Нет XSS уязвимостей
☐ Секреты не хардкодятся

ПРОИЗВОДИТЕЛЬНОСТЬ:
☐ Нет очевидной неэффективности
☐ Запросы к БД оптимизированы
☐ Рассмотрена корректная индексация
☐ Кеширование где уместно

ПОДДЕРЖИВАЕМОСТЬ:
☐ Код читаем
☐ Функции сфокусированы
☐ Имена имеют смысл
☐ Комментарии объясняют "почему", а не "что"

ТЕСТИРОВАНИЕ:
☐ Юнит-тесты присутствуют
☐ Граничные случаи протестированы
☐ Интеграционные тесты (при необходимости)
☐ Случаи ошибок покрыты
```

---

## XII. КОНТРОЛЬ ВЕРСИЙ

### Сообщения коммитов
```
Формат:
<тип>(<область>): <тема>

<тело>

<футер>

Типы: feat, fix, docs, style, refactor, test, chore

Пример:
feat(auth): добавлен механизм обновления JWT токена

- Реализован endpoint обновления токена
- Добавлен refresh token в схему БД
- Обновлен клиент для обработки обновления токена

Closes #123
```

### Лучшие практики Git
```
✓ Атомарные коммиты (одно логическое изменение)
✓ Описательные сообщения коммитов
✓ Ветки для функций
✓ Ревью pull request'ов
✓ Никаких секретов в коммитах
✓ Осмысленные имена веток
```

---

## XIII. РАБОТА С МНОГОФАЙЛОВЫМИ ПРОЕКТАМИ

### При работе с несколькими файлами
1. **Понять структуру** - Спросите об организации файлов, если неясно
2. **Поддерживать согласованность** - Следуйте существующим паттернам
3. **Учитывать зависимости** - Обновляйте связанные файлы
4. **Думать о миграции** - Предлагайте пути обновления для breaking changes

### Понимание структуры проекта
```
src/
├── components/     # React компоненты
├── services/       # Бизнес-логика
├── utils/          # Вспомогательные функции
├── types/          # TypeScript типы
└── tests/          # Тестовые файлы

# Следуйте соглашениям проекта
# Размещайте файлы в соответствующих директориях
# Используйте согласованное именование
```

---

## XIV. ИНСАЙТЫ НА ОСНОВЕ ИССЛЕДОВАНИЙ (2024-2025)

### Что работает ✅
- Четкие, конкретные инструкции
- Предоставление релевантного контекста
- Zero-shot для простых задач
- 2-5 качественных примеров для паттернов
- Прямые промпты для современных моделей
- Явные требования к формату
- Приоритет безопасности

### Что работает плохо ❌
- Чрезмерно сложные промпты
- "Думай пошагово" для простого кода
- Больше 5 примеров
- Ролевые игры для точности
- Допущение согласованности AI без тестирования
- Размытые требования

### Ключевые находки
1. **Возможности модели > Трюки с промптингом** (2025)
2. **Zero-shot удивительно эффективен** для современных LLM
3. **Few-shot имеет убывающую отдачу** после 5 примеров
4. **CoT не всегда полезен** для моделей с рассуждениями
5. **Качество примеров > количество** во всех случаях

---

## XV. БЫСТРЫЙ СПРАВОЧНИК

### Шаблоны запросов

#### Исправление бага
```
"Исправь [тип ошибки] в [файл] строка [номер]:
Ошибка: [сообщение об ошибке]
Ожидается: [поведение]
Фактически: [поведение]
Контекст: [релевантный код]"
```

#### Новая функция
```
"Реализуй [функцию] с:
- [Требование 1]
- [Требование 2]
- [Требование 3]
Язык: [язык]
Фреймворк: [фреймворк]"
```

#### Рефакторинг
```
"Отрефактори [функцию/класс] для:
1. [Цель 1]
2. [Цель 2]
Текущий код: [вставка]"
```

#### Оптимизация
```
"Оптимизируй [компонент] для [метрика]:
Текущая производительность: [измерение]
Цель: [задача]
Ограничения: [лимиты]"
```

---

## XVI. ЭФФЕКТИВНОСТЬ ИСПОЛЬЗОВАНИЯ ТОКЕНОВ (Production)

### Оптимизация затрат
```
✓ Минимизировать избыточные объяснения
✓ Использовать комментарии в коде вместо внешнего текста
✓ Быть лаконичным в production
✓ Кешировать общие контексты
✓ Переиспользовать системные промпты
```

**Исследование:** Оптимизированные промпты могут снизить затраты на 76% при сохранении качества.

---

## XVII. НЕПРЕРЫВНОЕ ОБУЧЕНИЕ

### Оставайтесь в курсе
- Следите за обновлениями языка/фреймворка
- Изучайте новые паттерны и идиомы
- Понимайте лучшие практики безопасности
- Отслеживайте тренды производительности
- Просматривайте последние исследования

### При неуверенности
```
✓ Признавайте ограничения
✓ Предлагайте несколько подходов
✓ Рекомендуйте тестирование
✓ Указывайте на документацию
✓ Поощряйте эксперименты
```

---

## XVIII. ЗАМЕТКИ ДЛЯ КОНКРЕТНЫХ IDE

### GitHub Copilot
- Работает inline и в чате
- Поддерживает промпты на основе комментариев
- Хорош для автодополнения кода

### JetBrains AI
- Глубокая интеграция с IDE
- Отличная поддержка рефакторинга
- Сильная осведомленность о типах

### Codeium
- Поддержка многих языков
- Быстрое автодополнение
- Хорошая осведомленность о контексте

### Tabnine
- Модели обучения для команды
- Ориентация на приватность
- Адаптивные предложения

---

## XIX. ФИНАЛЬНЫЕ ПРИНЦИПЫ

**Помните:**
1. **Качество кода > Умные решения**
2. **Читаемость > Краткость** (обычно)
3. **Работающее > Идеальное** (изначально)
4. **Безопасность > Удобство**
5. **Протестированное > Предполагаемо работающее**
6. **Поддерживаемое > Оптимальное** (в большинстве случаев)

**Для максимальной эффективности:**
- Предоставляйте четкие требования
- Включайте релевантный контекст
- Указывайте ограничения
- Тестируйте результат
- Итерируйте по необходимости

---

**Именование файла:** Сохраните как `.ai-instructions`, `.copilot-instructions` или подобное в корне проекта.

**Частота обновления:** Пересматривайте ежеквартально или после крупных обновлений LLM.

**Атрибуция:** Правила на основе исследований от OpenAI, Anthropic, Google, Meta и академических институтов (2024-2025).

**Лицензия:** MIT / CC BY 4.0 - Используйте свободно, модифицируйте по необходимости.
